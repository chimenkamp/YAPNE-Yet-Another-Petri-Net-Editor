[
  "Solver: class SolverImpl {\n          get ptr() {\n            _assertPtr(this._ptr);\n            return this._ptr;\n          }\n          constructor(ptr = Z3.mk_solver(contextPtr)) {\n            this.ctx = ctx;\n            let myPtr;\n            if (typeof ptr === \"string\") {\n              myPtr = check(Z3.mk_solver_for_logic(contextPtr, _toSymbol(ptr)));\n            } else {\n              myPtr = ptr;\n            }\n            this._ptr = myPtr;\n            Z3.solver_inc_ref(contextPtr, myPtr);\n            cleanup.register(this, () => Z3.solver_dec_ref(contextPtr, myPtr), this);\n          }\n          set(key, value) {\n            Z3.solver_set_params(contextPtr, this.ptr, _toParams(key, value));\n          }\n          push() {\n            Z3.solver_push(contextPtr, this.ptr);\n          }\n          pop(num = 1) {\n            Z3.solver_pop(contextPtr, this.ptr, num);\n          }\n          numScopes() {\n            return Z3.solver_get_num_scopes(contextPtr, this.ptr);\n          }\n          reset() {\n            Z3.solver_reset(contextPtr, this.ptr);\n          }\n          add(...exprs) {\n            _flattenArgs(exprs).forEach((expr) => {\n              _assertContext(expr);\n              check(Z3.solver_assert(contextPtr, this.ptr, expr.ast));\n            });\n          }\n          addAndTrack(expr, constant) {\n            if (typeof constant === \"string\") {\n              constant = Bool.const(constant);\n            }\n            (0, utils_1.assert)(isConst(constant), \"Provided expression that is not a constant to addAndTrack\");\n            check(Z3.solver_assert_and_track(contextPtr, this.ptr, expr.ast, constant.ast));\n          }\n          assertions() {\n            return new AstVectorImpl(check(Z3.solver_get_assertions(contextPtr, this.ptr)));\n          }\n          async check(...exprs) {\n            const assumptions = _flattenArgs(exprs).map((expr) => {\n              _assertContext(expr);\n              return expr.ast;\n            });\n            const result = await asyncMutex.runExclusive(() => check(Z3.solver_check_assumptions(contextPtr, this.ptr, assumptions)));\n            switch (result) {\n              case low_level_1.Z3_lbool.Z3_L_FALSE:\n                return \"unsat\";\n              case low_level_1.Z3_lbool.Z3_L_TRUE:\n                return \"sat\";\n              case low_level_1.Z3_lbool.Z3_L_UNDEF:\n                return \"unknown\";\n              default:\n                (0, utils_1.assertExhaustive)(result);\n            }\n          }\n          model() {\n            return new ModelImpl(check(Z3.solver_get_model(contextPtr, this.ptr)));\n          }\n          toString() {\n            return check(Z3.solver_to_string(contextPtr, this.ptr));\n          }\n          fromString(s) {\n            Z3.solver_from_string(contextPtr, this.ptr, s);\n            throwIfError();\n          }\n          release() {\n            Z3.solver_dec_ref(contextPtr, this.ptr);\n            this._ptr = null;\n            cleanup.unregister(this);\n          }\n        }",
  "Optimize: class OptimizeImpl {\n          get ptr() {\n            _assertPtr(this._ptr);\n            return this._ptr;\n          }\n          constructor(ptr = Z3.mk_optimize(contextPtr)) {\n            this.ctx = ctx;\n            let myPtr;\n            myPtr = ptr;\n            this._ptr = myPtr;\n            Z3.optimize_inc_ref(contextPtr, myPtr);\n            cleanup.register(this, () => Z3.optimize_dec_ref(contextPtr, myPtr), this);\n          }\n          set(key, value) {\n            Z3.optimize_set_params(contextPtr, this.ptr, _toParams(key, value));\n          }\n          push() {\n            Z3.optimize_push(contextPtr, this.ptr);\n          }\n          pop() {\n            Z3.optimize_pop(contextPtr, this.ptr);\n          }\n          add(...exprs) {\n            _flattenArgs(exprs).forEach((expr) => {\n              _assertContext(expr);\n              check(Z3.optimize_assert(contextPtr, this.ptr, expr.ast));\n            });\n          }\n          addSoft(expr, weight, id = \"\") {\n            if (isCoercibleRational(weight)) {\n              weight = `${weight.numerator}/${weight.denominator}`;\n            }\n            check(Z3.optimize_assert_soft(contextPtr, this.ptr, expr.ast, weight.toString(), _toSymbol(id)));\n          }\n          addAndTrack(expr, constant) {\n            if (typeof constant === \"string\") {\n              constant = Bool.const(constant);\n            }\n            (0, utils_1.assert)(isConst(constant), \"Provided expression that is not a constant to addAndTrack\");\n            check(Z3.optimize_assert_and_track(contextPtr, this.ptr, expr.ast, constant.ast));\n          }\n          assertions() {\n            return new AstVectorImpl(check(Z3.optimize_get_assertions(contextPtr, this.ptr)));\n          }\n          maximize(expr) {\n            check(Z3.optimize_maximize(contextPtr, this.ptr, expr.ast));\n          }\n          minimize(expr) {\n            check(Z3.optimize_minimize(contextPtr, this.ptr, expr.ast));\n          }\n          async check(...exprs) {\n            const assumptions = _flattenArgs(exprs).map((expr) => {\n              _assertContext(expr);\n              return expr.ast;\n            });\n            const result = await asyncMutex.runExclusive(() => check(Z3.optimize_check(contextPtr, this.ptr, assumptions)));\n            switch (result) {\n              case low_level_1.Z3_lbool.Z3_L_FALSE:\n                return \"unsat\";\n              case low_level_1.Z3_lbool.Z3_L_TRUE:\n                return \"sat\";\n              case low_level_1.Z3_lbool.Z3_L_UNDEF:\n                return \"unknown\";\n              default:\n                (0, utils_1.assertExhaustive)(result);\n            }\n          }\n          model() {\n            return new ModelImpl(check(Z3.optimize_get_model(contextPtr, this.ptr)));\n          }\n          toString() {\n            return check(Z3.optimize_to_string(contextPtr, this.ptr));\n          }\n          fromString(s) {\n            Z3.optimize_from_string(contextPtr, this.ptr, s);\n            throwIfError();\n          }\n          release() {\n            Z3.optimize_dec_ref(contextPtr, this.ptr);\n            this._ptr = null;\n            cleanup.unregister(this);\n          }\n        }",
  "Model: class ModelImpl {\n          get ptr() {\n            _assertPtr(this._ptr);\n            return this._ptr;\n          }\n          constructor(ptr = Z3.mk_model(contextPtr)) {\n            this.ctx = ctx;\n            this._ptr = ptr;\n            Z3.model_inc_ref(contextPtr, ptr);\n            cleanup.register(this, () => Z3.model_dec_ref(contextPtr, ptr), this);\n          }\n          length() {\n            return Z3.model_get_num_consts(contextPtr, this.ptr) + Z3.model_get_num_funcs(contextPtr, this.ptr);\n          }\n          [Symbol.iterator]() {\n            return this.values();\n          }\n          *entries() {\n            const length = this.length();\n            for (let i = 0; i < length; i++) {\n              yield [i, this.get(i)];\n            }\n          }\n          *keys() {\n            for (const [key] of this.entries()) {\n              yield key;\n            }\n          }\n          *values() {\n            for (const [, value] of this.entries()) {\n              yield value;\n            }\n          }\n          decls() {\n            return [...this.values()];\n          }\n          sexpr() {\n            return check(Z3.model_to_string(contextPtr, this.ptr));\n          }\n          toString() {\n            return this.sexpr();\n          }\n          eval(expr, modelCompletion = false) {\n            _assertContext(expr);\n            const r = check(Z3.model_eval(contextPtr, this.ptr, expr.ast, modelCompletion));\n            if (r === null) {\n              throw new types_1.Z3Error(\"Failed to evaluate expression in the model\");\n            }\n            return _toExpr(r);\n          }\n          get(i, to) {\n            (0, utils_1.assert)(to === void 0 || typeof i === \"number\");\n            if (typeof i === \"number\") {\n              const length = this.length();\n              if (i >= length) {\n                throw new RangeError(`expected index ${i} to be less than length ${length}`);\n              }\n              if (to === void 0) {\n                const numConsts = check(Z3.model_get_num_consts(contextPtr, this.ptr));\n                if (i < numConsts) {\n                  return new FuncDeclImpl(check(Z3.model_get_const_decl(contextPtr, this.ptr, i)));\n                } else {\n                  return new FuncDeclImpl(check(Z3.model_get_func_decl(contextPtr, this.ptr, i - numConsts)));\n                }\n              }\n              if (to < 0) {\n                to += length;\n              }\n              if (to >= length) {\n                throw new RangeError(`expected index ${to} to be less than length ${length}`);\n              }\n              const result = [];\n              for (let j = i; j < to; j++) {\n                result.push(this.get(j));\n              }\n              return result;\n            } else if (isFuncDecl(i) || isExpr(i) && isConst(i)) {\n              const result = this.getInterp(i);\n              (0, utils_1.assert)(result !== null);\n              return result;\n            } else if (isSort(i)) {\n              return this.getUniverse(i);\n            }\n            (0, utils_1.assert)(false, \"Number, declaration or constant expected\");\n          }\n          updateValue(decl, a) {\n            _assertContext(decl);\n            _assertContext(a);\n            if (isExpr(decl)) {\n              decl = decl.decl();\n            }\n            if (isFuncDecl(decl) && decl.arity() !== 0 && isFuncInterp(a)) {\n              const funcInterp = this.addFuncInterp(decl, a.elseValue());\n              for (let i = 0; i < a.numEntries(); i++) {\n                const e = a.entry(i);\n                const n = e.numArgs();\n                const args = global.Array(n).map((_, i2) => e.argValue(i2));\n                funcInterp.addEntry(args, e.value());\n              }\n              return;\n            }\n            if (!isFuncDecl(decl) || decl.arity() !== 0) {\n              throw new types_1.Z3Error(\"Expecting 0-ary function or constant expression\");\n            }\n            if (!isAst(a)) {\n              throw new types_1.Z3Error(\"Only func declarations can be assigned to func interpretations\");\n            }\n            check(Z3.add_const_interp(contextPtr, this.ptr, decl.ptr, a.ast));\n          }\n          addFuncInterp(decl, defaultValue) {\n            const fi = check(Z3.add_func_interp(contextPtr, this.ptr, decl.ptr, decl.range().cast(defaultValue).ptr));\n            return new FuncInterpImpl(fi);\n          }\n          getInterp(expr) {\n            (0, utils_1.assert)(isFuncDecl(expr) || isConst(expr), \"Declaration expected\");\n            if (isConst(expr)) {\n              (0, utils_1.assert)(isExpr(expr));\n              expr = expr.decl();\n            }\n            (0, utils_1.assert)(isFuncDecl(expr));\n            if (expr.arity() === 0) {\n              const result = check(Z3.model_get_const_interp(contextPtr, this.ptr, expr.ptr));\n              if (result === null) {\n                return null;\n              }\n              return _toExpr(result);\n            } else {\n              const interp = check(Z3.model_get_func_interp(contextPtr, this.ptr, expr.ptr));\n              if (interp === null) {\n                return null;\n              }\n              return new FuncInterpImpl(interp);\n            }\n          }\n          getUniverse(sort) {\n            _assertContext(sort);\n            return new AstVectorImpl(check(Z3.model_get_sort_universe(contextPtr, this.ptr, sort.ptr)));\n          }\n          release() {\n            Z3.model_dec_ref(contextPtr, this.ptr);\n            this._ptr = null;\n            cleanup.unregister(this);\n          }\n        }",
  "Tactic: class TacticImpl {\n          constructor(tactic) {\n            this.ctx = ctx;\n            let myPtr;\n            if (typeof tactic === \"string\") {\n              myPtr = check(Z3.mk_tactic(contextPtr, tactic));\n            } else {\n              myPtr = tactic;\n            }\n            this.ptr = myPtr;\n            Z3.tactic_inc_ref(contextPtr, myPtr);\n            cleanup.register(this, () => Z3.tactic_dec_ref(contextPtr, myPtr), this);\n          }\n        }",
  "AstVector: class AstVectorImpl {\n          constructor(ptr = Z3.mk_ast_vector(contextPtr)) {\n            this.ptr = ptr;\n            this.ctx = ctx;\n            Z3.ast_vector_inc_ref(contextPtr, ptr);\n            cleanup.register(this, () => Z3.ast_vector_dec_ref(contextPtr, ptr), this);\n          }\n          length() {\n            return Z3.ast_vector_size(contextPtr, this.ptr);\n          }\n          [Symbol.iterator]() {\n            return this.values();\n          }\n          *entries() {\n            const length = this.length();\n            for (let i = 0; i < length; i++) {\n              yield [i, this.get(i)];\n            }\n          }\n          *keys() {\n            for (let [key] of this.entries()) {\n              yield key;\n            }\n          }\n          *values() {\n            for (let [, value] of this.entries()) {\n              yield value;\n            }\n          }\n          get(from2, to) {\n            const length = this.length();\n            if (from2 < 0) {\n              from2 += length;\n            }\n            if (from2 >= length) {\n              throw new RangeError(`expected from index ${from2} to be less than length ${length}`);\n            }\n            if (to === void 0) {\n              return _toAst(check(Z3.ast_vector_get(contextPtr, this.ptr, from2)));\n            }\n            if (to < 0) {\n              to += length;\n            }\n            if (to >= length) {\n              throw new RangeError(`expected to index ${to} to be less than length ${length}`);\n            }\n            const result = [];\n            for (let i = from2; i < to; i++) {\n              result.push(_toAst(check(Z3.ast_vector_get(contextPtr, this.ptr, i))));\n            }\n            return result;\n          }\n          set(i, v) {\n            _assertContext(v);\n            if (i >= this.length()) {\n              throw new RangeError(`expected index ${i} to be less than length ${this.length()}`);\n            }\n            check(Z3.ast_vector_set(contextPtr, this.ptr, i, v.ast));\n          }\n          push(v) {\n            _assertContext(v);\n            check(Z3.ast_vector_push(contextPtr, this.ptr, v.ast));\n          }\n          resize(size) {\n            check(Z3.ast_vector_resize(contextPtr, this.ptr, size));\n          }\n          has(v) {\n            _assertContext(v);\n            for (const item of this.values()) {\n              if (item.eqIdentity(v)) {\n                return true;\n              }\n            }\n            return false;\n          }\n          sexpr() {\n            return check(Z3.ast_vector_to_string(contextPtr, this.ptr));\n          }\n        }",
  "AstMap: class AstMapImpl {\n          constructor(ptr = Z3.mk_ast_map(contextPtr)) {\n            this.ptr = ptr;\n            this.ctx = ctx;\n            Z3.ast_map_inc_ref(contextPtr, ptr);\n            cleanup.register(this, () => Z3.ast_map_dec_ref(contextPtr, ptr), this);\n          }\n          [Symbol.iterator]() {\n            return this.entries();\n          }\n          get size() {\n            return Z3.ast_map_size(contextPtr, this.ptr);\n          }\n          *entries() {\n            for (const key of this.keys()) {\n              yield [key, this.get(key)];\n            }\n          }\n          keys() {\n            return new AstVectorImpl(Z3.ast_map_keys(contextPtr, this.ptr));\n          }\n          *values() {\n            for (const [_, value] of this.entries()) {\n              yield value;\n            }\n          }\n          get(key) {\n            return _toAst(check(Z3.ast_map_find(contextPtr, this.ptr, key.ast)));\n          }\n          set(key, value) {\n            check(Z3.ast_map_insert(contextPtr, this.ptr, key.ast, value.ast));\n          }\n          delete(key) {\n            check(Z3.ast_map_erase(contextPtr, this.ptr, key.ast));\n          }\n          clear() {\n            check(Z3.ast_map_reset(contextPtr, this.ptr));\n          }\n          has(key) {\n            return check(Z3.ast_map_contains(contextPtr, this.ptr, key.ast));\n          }\n          sexpr() {\n            return check(Z3.ast_map_to_string(contextPtr, this.ptr));\n          }\n        }",
  "interrupt: function interrupt() {\n          check(Z3.interrupt(contextPtr));\n        }",
  "isModel: function isModel(obj) {\n          const r = obj instanceof ModelImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isAst: function isAst(obj) {\n          const r = obj instanceof AstImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isSort: function isSort(obj) {\n          const r = obj instanceof SortImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isFuncDecl: function isFuncDecl(obj) {\n          const r = obj instanceof FuncDeclImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isFuncInterp: function isFuncInterp(obj) {\n          const r = obj instanceof FuncInterpImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isApp: function isApp(obj) {\n          if (!isExpr(obj)) {\n            return false;\n          }\n          const kind = check(Z3.get_ast_kind(contextPtr, obj.ast));\n          return kind === low_level_1.Z3_ast_kind.Z3_NUMERAL_AST || kind === low_level_1.Z3_ast_kind.Z3_APP_AST;\n        }",
  "isConst: function isConst(obj) {\n          return isExpr(obj) && isApp(obj) && obj.numArgs() === 0;\n        }",
  "isExpr: function isExpr(obj) {\n          const r = obj instanceof ExprImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isVar: function isVar(obj) {\n          return isExpr(obj) && check(Z3.get_ast_kind(contextPtr, obj.ast)) === low_level_1.Z3_ast_kind.Z3_VAR_AST;\n        }",
  "isAppOf: function isAppOf(obj, kind) {\n          return isExpr(obj) && isApp(obj) && obj.decl().kind() === kind;\n        }",
  "isBool: function isBool(obj) {\n          const r = obj instanceof ExprImpl && obj.sort.kind() === low_level_1.Z3_sort_kind.Z3_BOOL_SORT;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isTrue: function isTrue(obj) {\n          return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_TRUE);\n        }",
  "isFalse: function isFalse(obj) {\n          return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_FALSE);\n        }",
  "isAnd: function isAnd(obj) {\n          return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_AND);\n        }",
  "isOr: function isOr(obj) {\n          return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_OR);\n        }",
  "isImplies: function isImplies(obj) {\n          return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_IMPLIES);\n        }",
  "isNot: function isNot(obj) {\n          return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_NOT);\n        }",
  "isEq: function isEq(obj) {\n          return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_EQ);\n        }",
  "isDistinct: function isDistinct(obj) {\n          return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_DISTINCT);\n        }",
  "isQuantifier: function isQuantifier(obj) {\n          const r = obj instanceof QuantifierImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isArith: function isArith(obj) {\n          const r = obj instanceof ArithImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isArithSort: function isArithSort(obj) {\n          const r = obj instanceof ArithSortImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isInt: function isInt(obj) {\n          return isArith(obj) && isIntSort(obj.sort);\n        }",
  "isIntVal: function isIntVal(obj) {\n          const r = obj instanceof IntNumImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isIntSort: function isIntSort(obj) {\n          return isSort(obj) && obj.kind() === low_level_1.Z3_sort_kind.Z3_INT_SORT;\n        }",
  "isReal: function isReal(obj) {\n          return isArith(obj) && isRealSort(obj.sort);\n        }",
  "isRealVal: function isRealVal(obj) {\n          const r = obj instanceof RatNumImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isRealSort: function isRealSort(obj) {\n          return isSort(obj) && obj.kind() === low_level_1.Z3_sort_kind.Z3_REAL_SORT;\n        }",
  "isBitVecSort: function isBitVecSort(obj) {\n          const r = obj instanceof BitVecSortImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isBitVec: function isBitVec(obj) {\n          const r = obj instanceof BitVecImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isBitVecVal: function isBitVecVal(obj) {\n          const r = obj instanceof BitVecNumImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isArraySort: function isArraySort(obj) {\n          const r = obj instanceof ArraySortImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isArray: function isArray(obj) {\n          const r = obj instanceof ArrayImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isConstArray: function isConstArray(obj) {\n          return isAppOf(obj, low_level_1.Z3_decl_kind.Z3_OP_CONST_ARRAY);\n        }",
  "isProbe: function isProbe(obj) {\n          const r = obj instanceof ProbeImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isTactic: function isTactic(obj) {\n          const r = obj instanceof TacticImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "isAstVector: function isAstVector(obj) {\n          const r = obj instanceof AstVectorImpl;\n          r && _assertContext(obj);\n          return r;\n        }",
  "eqIdentity: function eqIdentity(a, b) {\n          return a.eqIdentity(b);\n        }",
  "getVarIndex: function getVarIndex(obj) {\n          (0, utils_1.assert)(isVar(obj), \"Z3 bound variable expected\");\n          return Z3.get_index_value(contextPtr, obj.ast);\n        }",
  "from: function from(value) {\n          if (typeof value === \"boolean\") {\n            return Bool.val(value);\n          } else if (typeof value === \"number\") {\n            if (!Number.isFinite(value)) {\n              throw new Error(`cannot represent infinity/NaN (got ${value})`);\n            }\n            if (Math.floor(value) === value) {\n              return Int.val(value);\n            }\n            return Real.val(value);\n          } else if (isCoercibleRational(value)) {\n            return Real.val(value);\n          } else if (typeof value === \"bigint\") {\n            return Int.val(value);\n          } else if (isExpr(value)) {\n            return value;\n          }\n          (0, utils_1.assert)(false);\n        }",
  "solve: async function solve(...assertions) {\n          const solver = new ctx.Solver();\n          solver.add(...assertions);\n          const result = await solver.check();\n          if (result === \"sat\") {\n            return solver.model();\n          }\n          return result;\n        }",
  "If: function If(condition, onTrue, onFalse) {\n          if (isProbe(condition) && isTactic(onTrue) && isTactic(onFalse)) {\n            return Cond(condition, onTrue, onFalse);\n          }\n          (0, utils_1.assert)(!isProbe(condition) && !isTactic(onTrue) && !isTactic(onFalse), \"Mixed expressions and goals\");\n          if (typeof condition === \"boolean\") {\n            condition = Bool.val(condition);\n          }\n          onTrue = from(onTrue);\n          onFalse = from(onFalse);\n          return _toExpr(check(Z3.mk_ite(contextPtr, condition.ptr, onTrue.ast, onFalse.ast)));\n        }",
  "Distinct: function Distinct(...exprs) {\n          (0, utils_1.assert)(exprs.length > 0, \"Can't make Distinct ouf of nothing\");\n          return new BoolImpl(check(Z3.mk_distinct(contextPtr, exprs.map((expr) => {\n            expr = from(expr);\n            _assertContext(expr);\n            return expr.ast;\n          }))));\n        }",
  "Const: function Const(name2, sort) {\n          _assertContext(sort);\n          return _toExpr(check(Z3.mk_const(contextPtr, _toSymbol(name2), sort.ptr)));\n        }",
  "Consts: function Consts(names, sort) {\n          _assertContext(sort);\n          if (typeof names === \"string\") {\n            names = names.split(\" \");\n          }\n          return names.map((name2) => Const(name2, sort));\n        }",
  "FreshConst: function FreshConst(sort, prefix = \"c\") {\n          _assertContext(sort);\n          return _toExpr(Z3.mk_fresh_const(sort.ctx.ptr, prefix, sort.ptr));\n        }",
  "Var: function Var(idx, sort) {\n          _assertContext(sort);\n          return _toExpr(Z3.mk_bound(sort.ctx.ptr, idx, sort.ptr));\n        }",
  "Implies: function Implies(a, b) {\n          a = from(a);\n          b = from(b);\n          _assertContext(a, b);\n          return new BoolImpl(check(Z3.mk_implies(contextPtr, a.ptr, b.ptr)));\n        }",
  "Iff: function Iff(a, b) {\n          a = from(a);\n          b = from(b);\n          _assertContext(a, b);\n          return new BoolImpl(check(Z3.mk_iff(contextPtr, a.ptr, b.ptr)));\n        }",
  "Eq: function Eq(a, b) {\n          a = from(a);\n          b = from(b);\n          _assertContext(a, b);\n          return a.eq(b);\n        }",
  "Xor: function Xor(a, b) {\n          a = from(a);\n          b = from(b);\n          _assertContext(a, b);\n          return new BoolImpl(check(Z3.mk_xor(contextPtr, a.ptr, b.ptr)));\n        }",
  "Not: function Not(a) {\n          if (typeof a === \"boolean\") {\n            a = from(a);\n          }\n          _assertContext(a);\n          if (isProbe(a)) {\n            return new ProbeImpl(check(Z3.probe_not(contextPtr, a.ptr)));\n          }\n          return new BoolImpl(check(Z3.mk_not(contextPtr, a.ptr)));\n        }",
  "And: function And(...args) {\n          if (args.length == 1 && args[0] instanceof ctx.AstVector) {\n            args = [...args[0].values()];\n            (0, utils_1.assert)((0, utils_1.allSatisfy)(args, isBool) ?? true, \"AstVector containing not bools\");\n          }\n          const allProbes = (0, utils_1.allSatisfy)(args, isProbe) ?? false;\n          if (allProbes) {\n            return _probeNary(Z3.probe_and, args);\n          } else {\n            const castArgs = args.map(from);\n            _assertContext(...castArgs);\n            return new BoolImpl(check(Z3.mk_and(contextPtr, castArgs.map((arg) => arg.ptr))));\n          }\n        }",
  "Or: function Or(...args) {\n          if (args.length == 1 && args[0] instanceof ctx.AstVector) {\n            args = [...args[0].values()];\n            (0, utils_1.assert)((0, utils_1.allSatisfy)(args, isBool) ?? true, \"AstVector containing not bools\");\n          }\n          const allProbes = (0, utils_1.allSatisfy)(args, isProbe) ?? false;\n          if (allProbes) {\n            return _probeNary(Z3.probe_or, args);\n          } else {\n            const castArgs = args.map(from);\n            _assertContext(...castArgs);\n            return new BoolImpl(check(Z3.mk_or(contextPtr, castArgs.map((arg) => arg.ptr))));\n          }\n        }",
  "PbEq: function PbEq(args, coeffs, k) {\n          _assertContext(...args);\n          if (args.length !== coeffs.length) {\n            throw new Error(\"Number of arguments and coefficients must match\");\n          }\n          return new BoolImpl(check(Z3.mk_pbeq(contextPtr, args.map((arg) => arg.ast), coeffs, k)));\n        }",
  "PbGe: function PbGe(args, coeffs, k) {\n          _assertContext(...args);\n          if (args.length !== coeffs.length) {\n            throw new Error(\"Number of arguments and coefficients must match\");\n          }\n          return new BoolImpl(check(Z3.mk_pbge(contextPtr, args.map((arg) => arg.ast), coeffs, k)));\n        }",
  "PbLe: function PbLe(args, coeffs, k) {\n          _assertContext(...args);\n          if (args.length !== coeffs.length) {\n            throw new Error(\"Number of arguments and coefficients must match\");\n          }\n          return new BoolImpl(check(Z3.mk_pble(contextPtr, args.map((arg) => arg.ast), coeffs, k)));\n        }",
  "ForAll: function ForAll(quantifiers, body, weight = 1) {\n          if (!(0, utils_1.allSatisfy)(quantifiers, isConst)) {\n            throw new Error(\"Quantifier variables must be constants\");\n          }\n          return new NonLambdaQuantifierImpl(check(Z3.mk_quantifier_const_ex(\n            contextPtr,\n            true,\n            weight,\n            _toSymbol(\"\"),\n            _toSymbol(\"\"),\n            quantifiers.map((q) => q.ptr),\n            // The earlier check verifies these are all apps\n            [],\n            [],\n            body.ptr\n          )));\n        }",
  "Exists: function Exists(quantifiers, body, weight = 1) {\n          if (!(0, utils_1.allSatisfy)(quantifiers, isConst)) {\n            throw new Error(\"Quantifier variables must be constants\");\n          }\n          return new NonLambdaQuantifierImpl(check(Z3.mk_quantifier_const_ex(\n            contextPtr,\n            false,\n            weight,\n            _toSymbol(\"\"),\n            _toSymbol(\"\"),\n            quantifiers.map((q) => q.ptr),\n            // The earlier check verifies these are all apps\n            [],\n            [],\n            body.ptr\n          )));\n        }",
  "Lambda: function Lambda(quantifiers, expr) {\n          if (!(0, utils_1.allSatisfy)(quantifiers, isConst)) {\n            throw new Error(\"Quantifier variables must be constants\");\n          }\n          return new LambdaImpl(check(Z3.mk_lambda_const(contextPtr, quantifiers.map((q) => q.ptr), expr.ptr)));\n        }",
  "ToReal: function ToReal(expr) {\n          expr = from(expr);\n          _assertContext(expr);\n          (0, utils_1.assert)(isInt(expr), \"Int expression expected\");\n          return new ArithImpl(check(Z3.mk_int2real(contextPtr, expr.ast)));\n        }",
  "ToInt: function ToInt(expr) {\n          if (!isExpr(expr)) {\n            expr = Real.val(expr);\n          }\n          _assertContext(expr);\n          (0, utils_1.assert)(isReal(expr), \"Real expression expected\");\n          return new ArithImpl(check(Z3.mk_real2int(contextPtr, expr.ast)));\n        }",
  "IsInt: function IsInt(expr) {\n          if (!isExpr(expr)) {\n            expr = Real.val(expr);\n          }\n          _assertContext(expr);\n          (0, utils_1.assert)(isReal(expr), \"Real expression expected\");\n          return new BoolImpl(check(Z3.mk_is_int(contextPtr, expr.ast)));\n        }",
  "Sqrt: function Sqrt(a) {\n          if (!isExpr(a)) {\n            a = Real.val(a);\n          }\n          return a.pow(\"1/2\");\n        }",
  "Cbrt: function Cbrt(a) {\n          if (!isExpr(a)) {\n            a = Real.val(a);\n          }\n          return a.pow(\"1/3\");\n        }",
  "BV2Int: function BV2Int(a, isSigned) {\n          _assertContext(a);\n          return new ArithImpl(check(Z3.mk_bv2int(contextPtr, a.ast, isSigned)));\n        }",
  "Int2BV: function Int2BV(a, bits) {\n          if (isArith(a)) {\n            (0, utils_1.assert)(isInt(a), \"parameter must be an integer\");\n          } else {\n            (0, utils_1.assert)(typeof a !== \"number\" || Number.isSafeInteger(a), \"parameter must not have decimal places\");\n            a = Int.val(a);\n          }\n          return new BitVecImpl(check(Z3.mk_int2bv(contextPtr, bits, a.ast)));\n        }",
  "Concat: function Concat(...bitvecs) {\n          _assertContext(...bitvecs);\n          return bitvecs.reduce((prev, curr) => new BitVecImpl(check(Z3.mk_concat(contextPtr, prev.ast, curr.ast))));\n        }",
  "Cond: function Cond(probe, onTrue, onFalse) {\n          _assertContext(probe, onTrue, onFalse);\n          return new TacticImpl(check(Z3.tactic_cond(contextPtr, probe.ptr, onTrue.ptr, onFalse.ptr)));\n        }",
  "LT: function LT(a, b) {\n          return new BoolImpl(check(Z3.mk_lt(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "GT: function GT(a, b) {\n          return new BoolImpl(check(Z3.mk_gt(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "LE: function LE(a, b) {\n          return new BoolImpl(check(Z3.mk_le(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "GE: function GE(a, b) {\n          return new BoolImpl(check(Z3.mk_ge(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "ULT: function ULT(a, b) {\n          return new BoolImpl(check(Z3.mk_bvult(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "UGT: function UGT(a, b) {\n          return new BoolImpl(check(Z3.mk_bvugt(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "ULE: function ULE(a, b) {\n          return new BoolImpl(check(Z3.mk_bvule(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "UGE: function UGE(a, b) {\n          return new BoolImpl(check(Z3.mk_bvuge(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "SLT: function SLT(a, b) {\n          return new BoolImpl(check(Z3.mk_bvslt(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "SGT: function SGT(a, b) {\n          return new BoolImpl(check(Z3.mk_bvsgt(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "SLE: function SLE(a, b) {\n          return new BoolImpl(check(Z3.mk_bvsle(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "SGE: function SGE(a, b) {\n          return new BoolImpl(check(Z3.mk_bvsge(contextPtr, a.ast, a.sort.cast(b).ast)));\n        }",
  "Sum: function Sum(arg0, ...args) {\n          if (arg0 instanceof BitVecImpl) {\n            if (args.length !== 1) {\n              throw new Error(\"BitVec add only supports 2 arguments\");\n            }\n            return new BitVecImpl(check(Z3.mk_bvadd(contextPtr, arg0.ast, arg0.sort.cast(args[0]).ast)));\n          } else {\n            (0, utils_1.assert)(arg0 instanceof ArithImpl);\n            return new ArithImpl(check(Z3.mk_add(contextPtr, [arg0.ast].concat(args.map((arg) => arg0.sort.cast(arg).ast)))));\n          }\n        }",
  "Sub: function Sub(arg0, ...args) {\n          if (arg0 instanceof BitVecImpl) {\n            if (args.length !== 1) {\n              throw new Error(\"BitVec sub only supports 2 arguments\");\n            }\n            return new BitVecImpl(check(Z3.mk_bvsub(contextPtr, arg0.ast, arg0.sort.cast(args[0]).ast)));\n          } else {\n            (0, utils_1.assert)(arg0 instanceof ArithImpl);\n            return new ArithImpl(check(Z3.mk_sub(contextPtr, [arg0.ast].concat(args.map((arg) => arg0.sort.cast(arg).ast)))));\n          }\n        }",
  "Product: function Product(arg0, ...args) {\n          if (arg0 instanceof BitVecImpl) {\n            if (args.length !== 1) {\n              throw new Error(\"BitVec mul only supports 2 arguments\");\n            }\n            return new BitVecImpl(check(Z3.mk_bvmul(contextPtr, arg0.ast, arg0.sort.cast(args[0]).ast)));\n          } else {\n            (0, utils_1.assert)(arg0 instanceof ArithImpl);\n            return new ArithImpl(check(Z3.mk_mul(contextPtr, [arg0.ast].concat(args.map((arg) => arg0.sort.cast(arg).ast)))));\n          }\n        }",
  "Div: function Div(arg0, arg1) {\n          if (arg0 instanceof BitVecImpl) {\n            return new BitVecImpl(check(Z3.mk_bvsdiv(contextPtr, arg0.ast, arg0.sort.cast(arg1).ast)));\n          } else {\n            (0, utils_1.assert)(arg0 instanceof ArithImpl);\n            return new ArithImpl(check(Z3.mk_div(contextPtr, arg0.ast, arg0.sort.cast(arg1).ast)));\n          }\n        }",
  "BUDiv: function BUDiv(arg0, arg1) {\n          return new BitVecImpl(check(Z3.mk_bvudiv(contextPtr, arg0.ast, arg0.sort.cast(arg1).ast)));\n        }",
  "Neg: function Neg(a) {\n          if (a instanceof BitVecImpl) {\n            return new BitVecImpl(check(Z3.mk_bvneg(contextPtr, a.ast)));\n          } else {\n            (0, utils_1.assert)(a instanceof ArithImpl);\n            return new ArithImpl(check(Z3.mk_unary_minus(contextPtr, a.ast)));\n          }\n        }",
  "Mod: function Mod(a, b) {\n          if (a instanceof BitVecImpl) {\n            return new BitVecImpl(check(Z3.mk_bvsrem(contextPtr, a.ast, a.sort.cast(b).ast)));\n          } else {\n            (0, utils_1.assert)(a instanceof ArithImpl);\n            return new ArithImpl(check(Z3.mk_mod(contextPtr, a.ast, a.sort.cast(b).ast)));\n          }\n        }",
  "Select: function Select(array, ...indices) {\n          const args = indices.map((arg, i) => array.domain_n(i).cast(arg));\n          if (args.length === 1) {\n            return _toExpr(check(Z3.mk_select(contextPtr, array.ast, args[0].ast)));\n          }\n          const _args = args.map((arg) => arg.ast);\n          return _toExpr(check(Z3.mk_select_n(contextPtr, array.ast, _args)));\n        }",
  "Store: function Store(array, ...indicesAndValue) {\n          const args = indicesAndValue.map((arg, i) => {\n            if (i === indicesAndValue.length - 1) {\n              return array.range().cast(arg);\n            }\n            return array.domain_n(i).cast(arg);\n          });\n          if (args.length <= 1) {\n            throw new Error(\"Array store requires both index and value arguments\");\n          }\n          if (args.length === 2) {\n            return _toExpr(check(Z3.mk_store(contextPtr, array.ast, args[0].ast, args[1].ast)));\n          }\n          const _idxs = args.slice(0, args.length - 1).map((arg) => arg.ast);\n          return _toExpr(check(Z3.mk_store_n(contextPtr, array.ast, _idxs, args[args.length - 1].ast)));\n        }",
  "Extract: function Extract(hi, lo, val) {\n          return new BitVecImpl(check(Z3.mk_extract(contextPtr, hi, lo, val.ast)));\n        }",
  "substitute: function substitute(t, ...substitutions) {\n          _assertContext(t);\n          const from2 = [];\n          const to = [];\n          for (const [f, t2] of substitutions) {\n            _assertContext(f);\n            _assertContext(t2);\n            from2.push(f.ast);\n            to.push(t2.ast);\n          }\n          return _toExpr(check(Z3.substitute(contextPtr, t.ast, from2, to)));\n        }",
  "simplify: async function simplify(e) {\n          const result = await Z3.simplify(contextPtr, e.ast);\n          return _toExpr(check(result));\n        }",
  "ast_from_string: function ast_from_string(s) {\n          const sort_names = [];\n          const sorts = [];\n          const decl_names = [];\n          const decls = [];\n          const v = new AstVectorImpl(check(Z3.parse_smtlib2_string(contextPtr, s, sort_names, sorts, decl_names, decls)));\n          if (v.length() !== 1) {\n            throw new Error(\"Expected exactly one AST. Instead got \" + v.length() + \": \" + v.sexpr());\n          }\n          return v.get(0);\n        }",
  "SetUnion: function SetUnion(...args) {\n          return new SetImpl(check(Z3.mk_set_union(contextPtr, args.map((arg) => arg.ast))));\n        }",
  "SetIntersect: function SetIntersect(...args) {\n          return new SetImpl(check(Z3.mk_set_intersect(contextPtr, args.map((arg) => arg.ast))));\n        }",
  "SetDifference: function SetDifference(a, b) {\n          return new SetImpl(check(Z3.mk_set_difference(contextPtr, a.ast, b.ast)));\n        }",
  "SetHasSize: function SetHasSize(set, size) {\n          const a = typeof size === \"object\" ? Int.sort().cast(size) : Int.sort().cast(size);\n          return new BoolImpl(check(Z3.mk_set_has_size(contextPtr, set.ast, a.ast)));\n        }",
  "SetAdd: function SetAdd(set, elem) {\n          const arg = set.elemSort().cast(elem);\n          return new SetImpl(check(Z3.mk_set_add(contextPtr, set.ast, arg.ast)));\n        }",
  "SetDel: function SetDel(set, elem) {\n          const arg = set.elemSort().cast(elem);\n          return new SetImpl(check(Z3.mk_set_del(contextPtr, set.ast, arg.ast)));\n        }",
  "SetComplement: function SetComplement(set) {\n          return new SetImpl(check(Z3.mk_set_complement(contextPtr, set.ast)));\n        }",
  "EmptySet: function EmptySet(sort) {\n          return new SetImpl(check(Z3.mk_empty_set(contextPtr, sort.ptr)));\n        }",
  "FullSet: function FullSet(sort) {\n          return new SetImpl(check(Z3.mk_full_set(contextPtr, sort.ptr)));\n        }",
  "isMember: function isMember(elem, set) {\n          const arg = set.elemSort().cast(elem);\n          return new BoolImpl(check(Z3.mk_set_member(contextPtr, arg.ast, set.ast)));\n        }",
  "isSubset: function isSubset(a, b) {\n          return new BoolImpl(check(Z3.mk_set_subset(contextPtr, a.ast, b.ast)));\n        }"
]